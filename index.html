<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Paci√™ncia Cl√°ssica</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');

*{margin:0;padding:0;box-sizing:border-box;}
body{font-family:'Roboto',sans-serif;background:#0f4c3a;display:flex;justify-content:center;align-items:flex-start;padding:20px;min-height:100vh;}

.game-container{width:100%;max-width:1200px;}
.header{display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;gap:10px;flex-wrap:wrap;}
.header h1{font-size:2rem;color:#fff;}
.new-game-btn{padding:5px 12px;background:#ff6b6b;border:none;border-radius:6px;cursor:pointer;color:white;font-weight:700;transition:.3s;}
.new-game-btn:hover{background:#ff4c4c;}

.stats{color:white;font-weight:700;display:flex;gap:15px;align-items:center;}

.game-board{display:grid;grid-template-columns:repeat(7,1fr);gap:10px;position:relative;min-height:400px;}
.foundation,.tableau-pile,.stock,.waste{border:2px dashed rgba(255,255,255,0.3);border-radius:8px;position:relative;min-height:120px;background:rgba(255,255,255,0.05);overflow:hidden;}
.card{width:70px;height:100px;border-radius:8px;position:absolute;background:white;display:flex;flex-direction:column;justify-content:space-between;align-items:center;font-weight:700;cursor:pointer;box-shadow:0 3px 8px rgba(0,0,0,0.4);user-select:none;transition:.18s;display:flex;justify-content:center;align-items:center;touch-action:none;}
.card.red{color:#e74c3c;}
.card.face-down{background: linear-gradient(135deg,#1e3c72,#2a5298); color:white; cursor:default; font-size:24px;}
.card.dragging{opacity:0.95;transform:scale(1.05);z-index:1000;box-shadow:0 10px 25px rgba(0,0,0,0.6);}

.tableau-pile{min-height:150px;}
.tableau-pile .card{position:absolute;}
@media(max-width:1100px){ .game-board{grid-template-columns:repeat(5,1fr);} }
@media(max-width:900px){ .game-board{grid-template-columns:repeat(4,1fr);} .tableau-pile{min-height:120px;} }
@media(max-width:600px){ .game-board{grid-template-columns:repeat(3,1fr);} .card{width:50px;height:70px;font-size:14px;} .tableau-pile{min-height:100px;} }
@media(max-width:420px){ .game-board{grid-template-columns:repeat(3,1fr);} .card{width:44px;height:62px;font-size:12px;} .tableau-pile{min-height:90px;} }

/* Vit√≥ria e confete */
.win-message{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.9);color:white;padding:30px;border-radius:15px;text-align:center;z-index:2000;display:none;backdrop-filter:blur(10px);}
.win-title{font-size:2rem;color:#4ecdc4;margin-bottom:15px;}
.celebration{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:1500;}
.confetti{position:absolute;width:8px;height:8px;background:#4ecdc4;animation:confetti-fall 3s linear infinite;}
@keyframes confetti-fall{0%{transform:translateY(-100vh) rotate(0deg);opacity:1;}100%{transform:translateY(100vh) rotate(720deg);opacity:0;}}
</style>
</head>
<body>

<div class="game-container">
  <div class="header">
    <h1>üÉè Paci√™ncia</h1>
    <div class="stats">
      ‚è±Ô∏è <span id="time">00:00</span> üéØ <span id="moves">0</span> ‚≠ê <span id="score">0</span>
    </div>
    <button class="new-game-btn" onclick="game.newGame()">üîÑ Novo Jogo</button>
  </div>

  <div class="game-board">
    <div class="stock" id="stock"></div>
    <div class="waste" id="waste"></div>
    <div></div>
    <div class="foundation" id="foundation-0"></div>
    <div class="foundation" id="foundation-1"></div>
    <div class="foundation" id="foundation-2"></div>
    <div class="foundation" id="foundation-3"></div>
    <div class="tableau-pile" id="tableau-0"></div>
    <div class="tableau-pile" id="tableau-1"></div>
    <div class="tableau-pile" id="tableau-2"></div>
    <div class="tableau-pile" id="tableau-3"></div>
    <div class="tableau-pile" id="tableau-4"></div>
    <div class="tableau-pile" id="tableau-5"></div>
    <div class="tableau-pile" id="tableau-6"></div>
  </div>
</div>

<div class="win-message" id="winMessage">
  <div class="win-title">üéâ Parab√©ns!</div>
  <div>Voc√™ venceu o jogo!</div>
  <div class="stats">
    ‚è±Ô∏è <span id="finalTime"></span> üéØ <span id="finalMoves"></span> ‚≠ê <span id="finalScore"></span>
  </div>
  <button class="new-game-btn" onclick="game.closeWinMessage()">üîÑ Jogar Novamente</button>
</div>

<div class="celebration" id="celebration"></div>

<script>
class Solitaire {
  constructor(){
    this.suits=['‚ô†','‚ô•','‚ô£','‚ô¶'];
    this.ranks=['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
    this.stock=[]; this.waste=[]; this.foundations=[[],[],[],[]]; this.tableau=[[],[],[],[],[],[],[]];
    this.draggedCard=null; this.draggedFrom=null; this.offsetX=0; this.offsetY=0;
    this.lastX=null; this.lastY=null;
    this.moves=0; this.score=0; this.startTime=null; this.timer=null;
    this.init();
  }

  init(){ this.newGame(); }

  newGame(){
    this.deck=[];
    for(let s of this.suits) for(let r of this.ranks)
      this.deck.push({suit:s, rank:r, color:(s==='‚ô•'||s==='‚ô¶')?'red':'black', faceUp:false, id:`${s}${r}${Math.random().toString(36).slice(2,8)}`});
    for(let i=this.deck.length-1;i>0;i--){let j=Math.floor(Math.random()*(i+1)); [this.deck[i],this.deck[j]]=[this.deck[j],this.deck[i]];}

    this.stock=[...this.deck]; this.waste=[]; this.foundations=[[],[],[],[]]; this.tableau=[[],[],[],[],[],[],[]];
    this.moves=0; this.score=0; this.startTime=Date.now();
    if(this.timer) clearInterval(this.timer);
    this.timer=setInterval(()=>this.updateTime(),1000);

    for(let i=0;i<7;i++) for(let j=0;j<=i;j++){
      let card=this.stock.pop(); card.faceUp=(j===i); this.tableau[i].push(card);
    }
    this.render(); this.bindEvents();
  }

  render(){
    this.renderStock(); this.renderWaste(); this.renderFoundations(); this.renderTableau();
    document.getElementById('moves').innerText=this.moves; document.getElementById('score').innerText=this.score;
  }

  renderStock(){
    const stockEl=document.getElementById('stock'); stockEl.innerHTML='';
    if(this.stock.length>0){
      let cardEl=document.createElement('div');
      cardEl.className='card face-down';
      // place nicely inside stock
      cardEl.style.position='absolute'; cardEl.style.left='10px'; cardEl.style.top='10px';
      stockEl.appendChild(cardEl);
    }
  }

  renderWaste(){
    const wasteEl=document.getElementById('waste'); wasteEl.innerHTML='';
    if(this.waste.length>0){
      const card=this.waste[this.waste.length-1];
      const ce=this.createCardElement(card);
      ce.style.position='absolute'; ce.style.left='10px'; ce.style.top='10px';
      ce.dataset.pile='waste';
      wasteEl.appendChild(ce);
    }
  }

  renderFoundations(){
    for(let i=0;i<4;i++){
      const el=document.getElementById(`foundation-${i}`); el.innerHTML='';
      if(this.foundations[i].length>0){
        const top=this.foundations[i][this.foundations[i].length-1];
        const ce=this.createCardElement(top);
        ce.style.position='absolute'; ce.style.left='10px'; ce.style.top='10px';
        // mark as foundation so we can prevent dragging from it
        ce.dataset.pile=`foundation-${i}`;
        el.appendChild(ce);
      }
    }
  }

  renderTableau(){
    for(let i=0;i<7;i++){
      const el=document.getElementById(`tableau-${i}`); el.innerHTML='';
      this.tableau[i].forEach((card,index)=>{
        const cardEl=this.createCardElement(card);
        cardEl.style.top=`${index*25}px`;
        cardEl.dataset.col=i;
        cardEl.style.zIndex = index+1;
        el.appendChild(cardEl);
      });
    }
  }

  createCardElement(card){
    const el=document.createElement('div');
    el.className=`card ${card.color} ${card.faceUp?'':'face-down'}`;
    el.dataset.id=card.id;
    el.innerHTML=card.faceUp?`${card.rank}${card.suit}`:'üÇ†';
    // use both mouse and touch; startDrag handles touch/mouse differences
    el.addEventListener('mousedown',(e)=>this.startDrag(e,card));
    el.addEventListener('touchstart',(e)=>this.startDrag(e,card),{passive:false});
    return el;
  }

  startDrag(e,card){
    // don't start drag if card is face-down
    if(!card.faceUp) return;
    e.preventDefault();

    // detect source pile; prevent dragging from foundations
    const tableauEl = e.target.closest('.tableau-pile');
    const wasteEl = e.target.closest('.waste');
    const foundationEl = e.target.closest('.foundation');
    if(foundationEl) return; // do not allow dragging from foundations

    if(tableauEl) this.draggedFrom = tableauEl.id;
    else if(wasteEl) this.draggedFrom = 'waste';
    else this.draggedFrom = 'waste';

    this.draggedCard = card;

    const rect = e.target.getBoundingClientRect();
    const clientX = (e.clientX !== undefined) ? e.clientX : (e.touches && e.touches[0] && e.touches[0].clientX);
    const clientY = (e.clientY !== undefined) ? e.clientY : (e.touches && e.touches[0] && e.touches[0].clientY);
    this.offsetX = clientX - rect.left;
    this.offsetY = clientY - rect.top;
    this.lastX = clientX; this.lastY = clientY;

    // attach global move/end handlers
    document.onmousemove = (ev)=>this.drag(ev);
    document.onmouseup = ()=>{ this.drop(); document.onmousemove=null; document.onmouseup=null; };
    document.ontouchmove = (ev)=>this.drag(ev);
    document.ontouchend = ()=>{ this.drop(); document.ontouchmove=null; document.ontouchend=null; };
  }

  drag(e){
    if(!this.draggedCard) return;
    const clientX = (e.clientX !== undefined) ? e.clientX : (e.touches && e.touches[0] && e.touches[0].clientX);
    const clientY = (e.clientY !== undefined) ? e.clientY : (e.touches && e.touches[0] && e.touches[0].clientY);
    if(clientX==null || clientY==null) return;
    this.lastX = clientX; this.lastY = clientY;

    const el = document.querySelector(`[data-id='${this.draggedCard.id}']`);
    if(!el) return;
    el.classList.add('dragging');
    el.style.position='fixed';
    el.style.left=(clientX - this.offsetX) + 'px';
    el.style.top=(clientY - this.offsetY) + 'px';
    el.style.zIndex = 2000;
  }

  drop(){
    if(!this.draggedCard) return;
    const x = (this.lastX !== null) ? this.lastX : (window.innerWidth/2);
    const y = (this.lastY !== null) ? this.lastY : (window.innerHeight/2);

    const el = document.querySelector(`[data-id='${this.draggedCard.id}']`);
    if(el){
      el.classList.remove('dragging');
      el.style.position='absolute';
      el.style.left='0';
      el.style.top='0';
      el.style.zIndex = '';
    }

    let moved = false;

    // try tableau piles
    document.querySelectorAll('.tableau-pile').forEach((pile,i)=>{
      const rect = pile.getBoundingClientRect();
      if(rect.left < x && x < rect.right && rect.top < y && y < rect.bottom){
        if(this.canMoveTableau(this.draggedCard,this.draggedFrom,i)){
          this.moveTableau(this.draggedFrom,i,this.draggedCard);
          moved = true; this.moves++; this.score += 5;
        }
      }
    });

    // try foundations
    document.querySelectorAll('.foundation').forEach((f,i)=>{
      const rect = f.getBoundingClientRect();
      if(rect.left < x && x < rect.right && rect.top < y && y < rect.bottom){
        if(this.canMoveFoundation(this.draggedCard,i)){
          // handle removal from source properly
          if(this.draggedFrom === 'waste'){
            // only allowed if the top of waste is the dragged card (should be)
            const idx = this.waste.findIndex(c=>c.id===this.draggedCard.id);
            if(idx !== -1 && idx === this.waste.length-1){
              this.waste.pop();
              this.foundations[i].push(this.draggedCard);
              moved=true; this.moves++; this.score+=10;
            }
          } else if(this.draggedFrom && this.draggedFrom.startsWith('tableau-')){
            const fromCol = parseInt(this.draggedFrom.split('-')[1]);
            const col = this.tableau[fromCol];
            const idx = col.findIndex(c=>c.id===this.draggedCard.id);
            // only allow single top-card moves to foundation
            if(idx !== -1 && idx === col.length-1){
              // remove that card
              col.splice(idx,1);
              this.foundations[i].push(this.draggedCard);
              if(col.length>0) col[col.length-1].faceUp = true;
              moved=true; this.moves++; this.score+=10;
            }
          }
        }
      }
    });

    // don't push back into waste ‚Äî we never removed it when starting drag,
    // and move routines already take care of splicing/removal when moved.

    // cleanup
    this.draggedCard = null; this.draggedFrom = null;
    document.onmousemove=null; document.onmouseup=null; document.ontouchmove=null; document.ontouchend=null;

    this.render(); this.checkWin();
  }

  canMoveTableau(card,from,to){
    const dest=this.tableau[to];
    if(dest.length===0) return card.rank==='K';
    const top=dest[dest.length-1];
    const val=this.ranks.indexOf(card.rank);
    const topVal=this.ranks.indexOf(top.rank);
    return card.color!==top.color && val===topVal-1;
  }

  moveTableau(from,to,card){
    const colFrom = (from==='waste') ? this.waste : this.tableau[parseInt(from.split('-')[1])];
    if(!colFrom) return;
    const index = colFrom.findIndex(c=>c.id===card.id);
    if(index === -1) return;
    const moving = colFrom.splice(index); // remove from index to end (stack)
    this.tableau[to] = this.tableau[to].concat(moving);
    if(from!=='waste'){
      const f = parseInt(from.split('-')[1]);
      if(this.tableau[f].length>0) this.tableau[f][this.tableau[f].length-1].faceUp=true;
    }
  }

  canMoveFoundation(card,index){
    const pile=this.foundations[index];
    if(pile.length===0) return card.rank==='A';
    const top=pile[pile.length-1];
    const val=this.ranks.indexOf(card.rank);
    const topVal=this.ranks.indexOf(top.rank);
    return card.suit===top.suit && val===topVal+1;
  }

  bindEvents(){ document.getElementById('stock').onclick=()=>this.drawCard(); }

  drawCard(){
    if(this.stock.length===0){
      // recycle waste into stock (keeps behavior similar to original)
      if(this.waste.length===0) return;
      this.stock=[...this.waste.reverse()];
      this.waste=[];
    } else {
      const card=this.stock.pop();
      card.faceUp=true;
      this.waste.push(card);
      this.moves++;
      this.score++;
    }
    this.render(); this.checkWin();
  }

  updateTime(){
    const diff=Math.floor((Date.now()-this.startTime)/1000);
    const m=Math.floor(diff/60).toString().padStart(2,'0');
    const s=(diff%60).toString().padStart(2,'0');
    document.getElementById('time').innerText=`${m}:${s}`;
  }

  checkWin(){
    if(this.foundations.every(f=>f.length===13)){ this.showWin(); }
  }

  showWin(){
    document.getElementById('winMessage').style.display='block';
    document.getElementById('finalTime').innerText=document.getElementById('time').innerText;
    document.getElementById('finalMoves').innerText=this.moves;
    document.getElementById('finalScore').innerText=this.score;
    this.startConfetti();
  }

  closeWinMessage(){
    document.getElementById('winMessage').style.display='none';
    document.getElementById('celebration').innerHTML='';
    this.newGame();
  }

  startConfetti(){
    const c=document.getElementById('celebration'); c.innerHTML='';
    for(let i=0;i<100;i++){
      const d=document.createElement('div'); d.className='confetti'; d.style.left=Math.random()*window.innerWidth+'px'; d.style.backgroundColor=`hsl(${Math.random()*360},70%,60%)`; c.appendChild(d);
    }
    setTimeout(()=>{ c.innerHTML=''; },3000);
  }
}

const game=new Solitaire();
</script>
</body>
</html>
