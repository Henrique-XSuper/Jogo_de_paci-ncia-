<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Paci√™ncia Cl√°ssica</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');

*{margin:0;padding:0;box-sizing:border-box;}
body{font-family:'Roboto',sans-serif;background:#0f4c3a;display:flex;justify-content:center;align-items:flex-start;padding:20px;min-height:100vh;}

.game-container{width:100%;max-width:1200px;}
.header{display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;}
.header h1{font-size:2rem;color:#fff;}
.new-game-btn{padding:5px 12px;background:#ff6b6b;border:none;border-radius:6px;cursor:pointer;color:white;font-weight:700;transition:.3s;}
.new-game-btn:hover{background:#ff4c4c;}

.stats{color:white;font-weight:700;display:flex;gap:15px;align-items:center;}

.game-board{display:grid;grid-template-columns:repeat(7,1fr);gap:10px;position:relative;min-height:400px;}
.foundation,.tableau-pile,.stock,.waste{border:2px dashed rgba(255,255,255,0.3);border-radius:8px;position:relative;min-height:120px;background:rgba(255,255,255,0.05);}
.card{width:70px;height:100px;border-radius:8px;position:absolute;background:white;display:flex;flex-direction:column;justify-content:space-between;align-items:center;font-weight:700;cursor:pointer;box-shadow:0 3px 8px rgba(0,0,0,0.4);user-select:none;transition:.3s;display:flex;justify-content:center;align-items:center;}
.card.red{color:#e74c3c;}
.card.face-down{background: linear-gradient(135deg,#1e3c72,#2a5298); color:white; cursor:default; font-size:24px;}
.card.dragging{opacity:0.9;transform:scale(1.1);z-index:1000;box-shadow:0 10px 25px rgba(0,0,0,0.6);}

.tableau-pile{min-height:150px;}
.tableau-pile .card{position:absolute;}
@media(max-width:768px){.card{width:50px;height:70px;font-size:14px;}.tableau-pile{min-height:100px;}}

/* Vit√≥ria e confete */
.win-message{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.9);color:white;padding:30px;border-radius:15px;text-align:center;z-index:2000;display:none;backdrop-filter:blur(10px);}
.win-title{font-size:2rem;color:#4ecdc4;margin-bottom:15px;}
.celebration{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:1500;}
.confetti{position:absolute;width:8px;height:8px;background:#4ecdc4;animation:confetti-fall 3s linear infinite;}
@keyframes confetti-fall{0%{transform:translateY(-100vh) rotate(0deg);opacity:1;}100%{transform:translateY(100vh) rotate(720deg);opacity:0;}}
</style>
</head>
<body>

<div class="game-container">
  <div class="header">
    <h1>üÉè Paci√™ncia</h1>
    <div class="stats">
      ‚è±Ô∏è <span id="time">00:00</span> üéØ <span id="moves">0</span> ‚≠ê <span id="score">0</span>
    </div>
    <button class="new-game-btn" onclick="game.newGame()">üîÑ Novo Jogo</button>
  </div>

  <div class="game-board">
    <div class="stock" id="stock"></div>
    <div class="waste" id="waste"></div>
    <div></div>
    <div class="foundation" id="foundation-0"></div>
    <div class="foundation" id="foundation-1"></div>
    <div class="foundation" id="foundation-2"></div>
    <div class="foundation" id="foundation-3"></div>
    <div class="tableau-pile" id="tableau-0"></div>
    <div class="tableau-pile" id="tableau-1"></div>
    <div class="tableau-pile" id="tableau-2"></div>
    <div class="tableau-pile" id="tableau-3"></div>
    <div class="tableau-pile" id="tableau-4"></div>
    <div class="tableau-pile" id="tableau-5"></div>
    <div class="tableau-pile" id="tableau-6"></div>
  </div>
</div>

<div class="win-message" id="winMessage">
  <div class="win-title">üéâ Parab√©ns!</div>
  <div>Voc√™ venceu o jogo!</div>
  <div class="stats">
    ‚è±Ô∏è <span id="finalTime"></span> üéØ <span id="finalMoves"></span> ‚≠ê <span id="finalScore"></span>
  </div>
  <button class="new-game-btn" onclick="game.closeWinMessage()">üîÑ Jogar Novamente</button>
</div>

<div class="celebration" id="celebration"></div>

<script>
class Solitaire {
  constructor(){
    this.suits=['‚ô†','‚ô•','‚ô£','‚ô¶'];
    this.ranks=['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
    this.stock=[]; this.waste=[]; this.foundations=[[],[],[],[]]; this.tableau=[[],[],[],[],[],[],[]];
    this.draggedCard=null; this.draggedFrom=null; this.offsetX=0; this.offsetY=0;
    this.lastX=0; this.lastY=0;
    this.moves=0; this.score=0; this.startTime=null; this.timer=null;
    this.init();
  }

  init(){ this.newGame(); }

  newGame(){
    this.deck=[];
    for(let s of this.suits) for(let r of this.ranks)
      this.deck.push({suit:s, rank:r, color:(s==='‚ô•'||s==='‚ô¶')?'red':'black', faceUp:false, id:`${s}${r}${Math.random().toString(36).slice(2,7)}`});
    // shuffle
    for(let i=this.deck.length-1;i>0;i--){let j=Math.floor(Math.random()*(i+1)); [this.deck[i],this.deck[j]]=[this.deck[j],this.deck[i]];}

    this.stock=[...this.deck]; this.waste=[]; this.foundations=[[],[],[],[]]; this.tableau=[[],[],[],[],[],[],[]];
    this.moves=0; this.score=0; this.startTime=Date.now();
    if(this.timer) clearInterval(this.timer);
    this.timer=setInterval(()=>this.updateTime(),1000);

    // deal tableau
    for(let i=0;i<7;i++){
      for(let j=0;j<=i;j++){
        let card=this.stock.pop();
        card.faceUp=(j===i);
        this.tableau[i].push(card);
      }
    }
    this.render(); this.bindEvents();
  }

  render(){
    this.renderStock(); this.renderWaste(); this.renderFoundations(); this.renderTableau();
    document.getElementById('moves').innerText=this.moves;
    document.getElementById('score').innerText=this.score;
  }

  renderStock(){
    const stockEl=document.getElementById('stock'); stockEl.innerHTML='';
    if(this.stock.length>0){
      let cardEl=document.createElement('div');
      cardEl.className='card face-down';
      // keep pointer cursor on stock container, not card itself
      stockEl.appendChild(cardEl);
    }
  }

  renderWaste(){
    const wasteEl=document.getElementById('waste'); wasteEl.innerHTML='';
    if(this.waste.length>0){
      const card=this.waste[this.waste.length-1];
      const ce=this.createCardElement(card);
      // place it relatively inside waste
      ce.style.position='absolute';
      ce.style.left='10px';
      ce.style.top='10px';
      ce.dataset.pile='waste';
      wasteEl.appendChild(ce);
    }
  }

  renderFoundations(){
    for(let i=0;i<4;i++){
      const el=document.getElementById(`foundation-${i}`); el.innerHTML='';
      if(this.foundations[i].length>0){
        const top=this.foundations[i][this.foundations[i].length-1];
        const ce=this.createCardElement(top);
        ce.style.position='absolute';
        ce.style.left='10px';
        ce.style.top='10px';
        ce.dataset.pile=`foundation-${i}`;
        // prevent dragging from foundation
        ce.classList.add('no-drag');
        el.appendChild(ce);
      }
    }
  }

  renderTableau(){
    for(let i=0;i<7;i++){
      const el=document.getElementById(`tableau-${i}`); el.innerHTML='';
      this.tableau[i].forEach((card,index)=>{
        const cardEl=this.createCardElement(card);
        cardEl.style.top=`${index*25}px`;
        cardEl.dataset.pile=`tableau-${i}`;
        cardEl.dataset.index=index;
        // ensure stacking order
        cardEl.style.zIndex = index+1;
        el.appendChild(cardEl);
      });
    }
  }

  createCardElement(card){
    const el=document.createElement('div');
    // keep classes separate so face-down class works correctly
    el.classList.add('card');
    if(card.color==='red') el.classList.add('red');
    if(!card.faceUp) el.classList.add('face-down');
    el.dataset.id=card.id;
    el.innerHTML=card.faceUp?`${card.rank}${card.suit}`:'üÇ†';
    // event handlers
    el.addEventListener('mousedown', (e)=>this.startDrag(e,card));
    el.addEventListener('touchstart', (e)=>this.startDrag(e,card), {passive:false});
    return el;
  }

  startDrag(e,card){
    // don't allow dragging face-down or cards that are in foundations (no-drag)
    const targetEl = e.target.closest('.card');
    if(!targetEl) return;
    if(targetEl.classList.contains('face-down')) return;
    // disallow dragging foundation cards
    const pileEl = targetEl.closest('.tableau-pile') || targetEl.closest('.waste') || targetEl.closest('.foundation');
    if(pileEl && pileEl.classList.contains('foundation')) return;

    e.preventDefault();
    this.draggedCard = card;

    // determine source pile: tableau-#, waste, or foundation-# (we disallowed foundation above)
    if(pileEl){
      if(pileEl.classList.contains('tableau-pile')) this.draggedFrom = pileEl.id; // e.g. tableau-2
      else if(pileEl.classList.contains('waste')) this.draggedFrom = 'waste';
      else this.draggedFrom = pileEl.id;
    } else {
      this.draggedFrom = 'waste';
    }

    const rect = targetEl.getBoundingClientRect();
    const clientX = (e.clientX !== undefined) ? e.clientX : (e.touches && e.touches[0].clientX);
    const clientY = (e.clientY !== undefined) ? e.clientY : (e.touches && e.touches[0].clientY);
    this.offsetX = clientX - rect.left;
    this.offsetY = clientY - rect.top;

    // attach move/end handlers
    document.onmousemove = (ev)=>this.drag(ev);
    document.onmouseup = ()=>this.drop();
    document.ontouchmove = (ev)=>this.drag(ev);
    document.ontouchend = ()=>this.drop();
  }

  drag(e){
    if(!this.draggedCard) return;
    // update last pointer coords
    const clientX = (e.clientX !== undefined) ? e.clientX : (e.touches && e.touches[0].clientX);
    const clientY = (e.clientY !== undefined) ? e.clientY : (e.touches && e.touches[0].clientY);
    this.lastX = clientX; this.lastY = clientY;

    const el = document.querySelector(`[data-id='${this.draggedCard.id}']`);
    if(!el) return;
    el.classList.add('dragging');
    el.style.position='fixed';
    el.style.left=(clientX - this.offsetX) + 'px';
    el.style.top=(clientY - this.offsetY) + 'px';
    el.style.zIndex = 2000;
  }

  drop(){
    if(!this.draggedCard) return;
    const el = document.querySelector(`[data-id='${this.draggedCard.id}']`);
    if(el){
      el.classList.remove('dragging');
      // we'll re-render to place elements properly
      el.style.position='absolute';
      el.style.left='0';
      el.style.top='0';
      el.style.zIndex = '';
    }

    let moved = false;
    const x = this.lastX || (window.innerWidth/2);
    const y = this.lastY || (window.innerHeight/2);

    // try tableau piles
    const tableauPiles = document.querySelectorAll('.tableau-pile');
    tableauPiles.forEach((pile, i)=>{
      const rect = pile.getBoundingClientRect();
      if(rect.left < x && x < rect.right && rect.top < y && y < rect.bottom){
        if(this.canMoveTableau(this.draggedCard, this.draggedFrom, i)){
          this.moveTableau(this.draggedFrom, `tableau-${i}`, this.draggedCard);
          moved = true; this.moves++; this.score += 5;
        }
      }
    });

    // try foundations
    const foundationEls = document.querySelectorAll('.foundation');
    foundationEls.forEach((f, i)=>{
      const rect = f.getBoundingClientRect();
      if(rect.left < x && x < rect.right && rect.top < y && y < rect.bottom){
        if(this.canMoveFoundation(this.draggedCard, i)){
          // remove from source and push to foundation
          if(this.draggedFrom === 'waste'){
            // remove top of waste (should be it)
            const idx = this.waste.findIndex(c=>c.id===this.draggedCard.id);
            if(idx!==-1) this.waste.splice(idx,1);
          } else if(this.draggedFrom.startsWith('tableau-')){
            const fromIdx = parseInt(this.draggedFrom.split('-')[1]);
            const col = this.tableau[fromIdx];
            const index = col.findIndex(c=>c.id===this.draggedCard.id);
            if(index!==-1) col.splice(index);
            // after removing, flip top card if exists
            if(this.tableau[fromIdx].length>0) this.tableau[fromIdx][this.tableau[fromIdx].length-1].faceUp = true;
          }
          this.foundations[i].push(this.draggedCard);
          moved = true; this.moves++; this.score += 10;
        }
      }
    });

    // if not moved and source was waste, keep waste as it was (no action)
    // if not moved and source was tableau, nothing changes (we re-render)
    this.draggedCard = null;
    this.draggedFrom = null;

    this.render();
    this.checkWin();
  }

  canMoveTableau(card, from, toIndex){
    const dest = this.tableau[toIndex];
    if(dest.length === 0) return card.rank === 'K';
    const top = dest[dest.length-1];
    const val = this.ranks.indexOf(card.rank);
    const topVal = this.ranks.indexOf(top.rank);
    return card.color !== top.color && val === topVal - 1;
  }

  moveTableau(fromId, toId, card){
    // fromId: 'waste' or 'tableau-N'
    // toId: 'tableau-N'
    // identify source column array
    let colFrom;
    if(fromId === 'waste') colFrom = this.waste;
    else if(fromId && fromId.startsWith('tableau-')) colFrom = this.tableau[parseInt(fromId.split('-')[1])];
    else colFrom = null;

    if(!colFrom) return;

    const index = colFrom.findIndex(c=>c.id===card.id);
    if(index === -1) return;
    const moving = colFrom.splice(index); // takes card and any below (stack)
    const toIdx = parseInt(toId.split('-')[1]);
    this.tableau[toIdx] = this.tableau[toIdx].concat(moving);
    // flip top card of source tableau if needed
    if(fromId.startsWith('tableau-')){
      const f = parseInt(fromId.split('-')[1]);
      if(this.tableau[f].length>0) this.tableau[f][this.tableau[f].length-1].faceUp = true;
    } else if(fromId === 'waste'){
      // nothing else
    }
  }

  canMoveFoundation(card, index){
    const pile = this.foundations[index];
    if(pile.length === 0) return card.rank === 'A';
    const top = pile[pile.length-1];
    const val = this.ranks.indexOf(card.rank);
    const topVal = this.ranks.indexOf(top.rank);
    return card.suit === top.suit && val === topVal + 1;
  }

  bindEvents(){
    document.getElementById('stock').onclick = ()=>this.drawCard();
    // also allow clicking waste top to do nothing special (drag handled)
  }

  drawCard(){
    if(this.stock.length === 0){
      // recycle waste into stock (preserve order: top of waste becomes top of stock after flipping)
      if(this.waste.length === 0) return;
      // reverse waste and flip faceDown
      this.stock = this.waste.slice().reverse().map(c=>{ c.faceUp = false; return c; });
      this.waste = [];
      // no score change here (keeps simple scoring)
    } else {
      const card = this.stock.pop();
      card.faceUp = true;
      this.waste.push(card);
      this.moves++;
      this.score++;
    }
    this.render();
    this.checkWin();
  }

  updateTime(){
    const diff=Math.floor((Date.now()-this.startTime)/1000);
    const m=Math.floor(diff/60).toString().padStart(2,'0');
    const s=(diff%60).toString().padStart(2,'0');
    document.getElementById('time').innerText=`${m}:${s}`;
  }

  checkWin(){
    if(this.foundations.every(f=>f.length===13)){
      this.showWin();
    }
  }

  showWin(){
    document.getElementById('winMessage').style.display='block';
    document.getElementById('finalTime').innerText=document.getElementById('time').innerText;
    document.getElementById('finalMoves').innerText=this.moves;
    document.getElementById('finalScore').innerText=this.score;
    this.startConfetti();
  }

  closeWinMessage(){
    document.getElementById('winMessage').style.display='none';
    document.getElementById('celebration').innerHTML='';
    this.newGame();
  }

  startConfetti(){
    const c=document.getElementById('celebration'); c.innerHTML='';
    for(let i=0;i<100;i++){
      const d=document.createElement('div'); d.className='confetti';
      d.style.left=Math.random()*window.innerWidth+'px';
      d.style.backgroundColor=`hsl(${Math.random()*360},70%,60%)`;
      d.style.top = (-Math.random()*200) + 'px';
      d.style.transform = `rotate(${Math.random()*360}deg)`;
      c.appendChild(d);
    }
    setTimeout(()=>{ c.innerHTML=''; },3000);
  }
}

const game = new Solitaire();
  }

  render(){
    this.renderStock(); this.renderWaste(); this.renderFoundations(); this.renderTableau();
    document.getElementById('moves').innerText=this.moves; document.getElementById('score').innerText=this.score;
  }

  renderStock(){ const stockEl=document.getElementById('stock'); stockEl.innerHTML=''; if(this.stock.length>0){ let cardEl=document.createElement('div'); cardEl.className='card face-down'; stockEl.appendChild(cardEl); }}

  renderWaste(){ const wasteEl=document.getElementById('waste'); wasteEl.innerHTML=''; if(this.waste.length>0){ const card=this.waste[this.waste.length-1]; wasteEl.appendChild(this.createCardElement(card)); }}

  renderFoundations(){ for(let i=0;i<4;i++){ const el=document.getElementById(`foundation-${i}`); el.innerHTML=''; if(this.foundations[i].length>0) el.appendChild(this.createCardElement(this.foundations[i][this.foundations[i].length-1])); }}

  renderTableau(){
    for(let i=0;i<7;i++){
      const el=document.getElementById(`tableau-${i}`); el.innerHTML='';
      this.tableau[i].forEach((card,index)=>{
        const cardEl=this.createCardElement(card);
        cardEl.style.top=`${index*25}px`;
        cardEl.dataset.col=i;
        el.appendChild(cardEl);
      });
    }
  }

  createCardElement(card){
    const el=document.createElement('div');
    el.className=`card ${card.color} ${card.faceUp?'':'face-down'}`;
    el.dataset.id=card.id;
    el.innerHTML=card.faceUp?`${card.rank}${card.suit}`:'üÇ†';
    el.onmousedown=(e)=>this.startDrag(e,card); el.ontouchstart=(e)=>this.startDrag(e,card);
    return el;
  }

  startDrag(e,card){
    if(!card.faceUp) return; e.preventDefault();
    this.draggedCard=card;
    this.draggedFrom=e.target.closest('.tableau-pile')?.id || 'waste';
    const rect=e.target.getBoundingClientRect();
    this.offsetX=(e.clientX||e.touches[0].clientX)-rect.left;
    this.offsetY=(e.clientY||e.touches[0].clientY)-rect.top;
    document.onmousemove=(ev)=>this.drag(ev);
    document.onmouseup=()=>this.drop();
    document.ontouchmove=(ev)=>this.drag(ev);
    document.ontouchend=()=>this.drop();
  }

  drag(e){ if(!this.draggedCard) return; const el=document.querySelector(`[data-id='${this.draggedCard.id}']`); el.classList.add('dragging'); const x=(e.clientX||e.touches[0].clientX)-this.offsetX; const y=(e.clientY||e.touches[0].clientY)-this.offsetY; el.style.position='fixed'; el.style.left=x+'px'; el.style.top=y+'px'; }

  drop(){
    if(!this.draggedCard) return;
    const el=document.querySelector(`[data-id='${this.draggedCard.id}']`);
    el.classList.remove('dragging'); el.style.position='absolute'; el.style.left='0'; el.style.top='0';
    let moved=false;

    document.querySelectorAll('.tableau-pile').forEach((pile,i)=>{
      const rect=pile.getBoundingClientRect();
      if(rect.left<window.event.clientX && window.event.clientX<rect.right && rect.top<window.event.clientY && window.event.clientY<rect.bottom){
        if(this.canMoveTableau(this.draggedCard,this.draggedFrom,i)){
          this.moveTableau(this.draggedFrom,i,this.draggedCard); moved=true; this.moves++; this.score+=5;
        }
      }
    });

    document.querySelectorAll('.foundation').forEach((f,i)=>{
      const rect=f.getBoundingClientRect();
      if(rect.left<window.event.clientX && window.event.clientX<rect.right && rect.top<window.event.clientY && window.event.clientY<rect.bottom){
        if(this.canMoveFoundation(this.draggedCard,i)){
          this.foundations[i].push(this.draggedCard);
          if(this.draggedFrom!=='waste'){ const fromCol=parseInt(this.draggedFrom.split('-')[1]); this.tableau[fromCol]=this.tableau[fromCol].filter(c=>c.id!==this.draggedCard.id); if(this.tableau[fromCol].length>0) this.tableau[fromCol][this.tableau[fromCol].length-1].faceUp=true; }
          else this.waste.pop();
          moved=true; this.moves++; this.score+=10;
        }
      }
    });

    if(!moved && this.draggedFrom==='waste'){ this.waste.push(this.draggedCard); }
    this.draggedCard=null; this.draggedFrom=null;
    this.render(); this.checkWin();
  }

  canMoveTableau(card,from,to){ const dest=this.tableau[to]; if(dest.length===0) return card.rank==='K'; const top=dest[dest.length-1]; const val=this.ranks.indexOf(card.rank); const topVal=this.ranks.indexOf(top.rank); return card.color!==top.color && val===topVal-1; }

  moveTableau(from,to,card){
    const colFrom=from==='waste'?this.waste:this.tableau[parseInt(from.split('-')[1])];
    const index=colFrom.findIndex(c=>c.id===card.id);
    const moving=colFrom.splice(index);
    this.tableau[to]=this.tableau[to].concat(moving);
    if(from!=='waste'){ const f=parseInt(from.split('-')[1]); if(this.tableau[f].length>0) this.tableau[f][this.tableau[f].length-1].faceUp=true; }
  }

  canMoveFoundation(card,index){
    const pile=this.foundations[index]; if(pile.length===0) return card.rank==='A';
    const top=pile[pile.length-1]; const val=this.ranks.indexOf(card.rank); const topVal=this.ranks.indexOf(top.rank);
    return card.suit===top.suit && val===topVal+1;
  }

  bindEvents(){ document.getElementById('stock').onclick=()=>this.drawCard(); }

  drawCard(){
    if(this.stock.length===0){ this.stock=[...this.waste.reverse()]; this.waste=[]; }
    else{ const card=this.stock.pop(); card.faceUp=true; this.waste.push(card); this.moves++; this.score++; }
    this.render(); this.checkWin();
  }

  updateTime(){
    const diff=Math.floor((Date.now()-this.startTime)/1000); const m=Math.floor(diff/60).toString().padStart(2,'0'); const s=(diff%60).toString().padStart(2,'0'); document.getElementById('time').innerText=`${m}:${s}`;
  }

  checkWin(){
    if(this.foundations.every(f=>f.length===13)){ this.showWin(); }
  }

  showWin(){
    document.getElementById('winMessage').style.display='block';
    document.getElementById('finalTime').innerText=document.getElementById('time').innerText;
    document.getElementById('finalMoves').innerText=this.moves;
    document.getElementById('finalScore').innerText=this.score;
    this.startConfetti();
  }

  closeWinMessage(){
    document.getElementById('winMessage').style.display='none';
    document.getElementById('celebration').innerHTML='';
    this.newGame();
  }

  startConfetti(){
    const c=document.getElementById('celebration'); c.innerHTML='';
    for(let i=0;i<100;i++){
      const d=document.createElement('div'); d.className='confetti'; d.style.left=Math.random()*window.innerWidth+'px'; d.style.backgroundColor=`hsl(${Math.random()*360},70%,60%)`; c.appendChild(d);
    }
    setTimeout(()=>{ c.innerHTML=''; },3000);
  }
}

const game=new Solitaire();
</script>
</body>
</html>

  
