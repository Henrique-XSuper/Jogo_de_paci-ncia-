<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Paci√™ncia Cl√°ssica</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Roboto', sans-serif;
  background: linear-gradient(135deg, #0f4c3a 0%, #1a6d5a 100%);
  display: flex;
  justify-content: center;
  align-items: flex-start;
  padding: 10px;
  min-height: 100vh;
  overflow-x: auto;
}

.game-container {
  width: 100%;
  max-width: 1200px;
  min-width: 320px;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  gap: 10px;
  flex-wrap: wrap;
}

.header h1 {
  font-size: clamp(1.2rem, 4vw, 2rem);
  color: #fff;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
}

.new-game-btn {
  padding: 8px 16px;
  background: #ff6b6b;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  color: white;
  font-weight: 700;
  font-size: clamp(12px, 2.5vw, 16px);
  transition: all 0.3s ease;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  touch-action: manipulation;
}

.new-game-btn:hover {
  background: #ff4c4c;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
}

.stats {
  color: white;
  font-weight: 700;
  display: flex;
  gap: 15px;
  align-items: center;
  font-size: clamp(12px, 2.5vw, 16px);
  text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
}

.game-board {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  gap: 8px;
  position: relative;
  min-height: 400px;
}

.foundation, .tableau-pile, .stock, .waste {
  border: 2px dashed rgba(255,255,255,0.4);
  border-radius: 10px;
  position: relative;
  min-height: 120px;
  background: rgba(255,255,255,0.1);
  overflow: visible;
  backdrop-filter: blur(5px);
  transition: all 0.3s ease;
}

.foundation:hover, .tableau-pile:hover, .stock:hover, .waste:hover {
  border-color: rgba(255,255,255,0.6);
  background: rgba(255,255,255,0.15);
}

.card {
  width: 70px;
  height: 100px;
  border-radius: 10px;
  position: absolute;
  background: linear-gradient(145deg, #ffffff, #f0f0f0);
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  font-weight: 700;
  cursor: pointer;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  user-select: none;
  transition: all 0.2s ease;
  touch-action: none;
  border: 1px solid rgba(0,0,0,0.1);
  font-size: clamp(10px, 2vw, 14px);
}

.card.red {
  color: #e74c3c;
}

.card.black {
  color: #2c3e50;
}

.card.face-down {
  background: linear-gradient(135deg, #1e3c72, #2a5298);
  color: white;
  cursor: default;
  font-size: 24px;
}

.card.dragging {
  opacity: 0.9;
  transform: scale(1.08);
  z-index: 1000;
  box-shadow: 0 15px 35px rgba(0,0,0,0.5);
  transition: none;
}

.tableau-pile {
  min-height: 200px;
}

.tableau-pile .card {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
}

.stock .card, .waste .card, .foundation .card {
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
}

.drop-zone {
  border-color: #4ecdc4 !important;
  background: rgba(78, 205, 196, 0.2) !important;
  box-shadow: 0 0 20px rgba(78, 205, 196, 0.3);
}

/* Responsividade aprimorada */
@media (max-width: 1100px) {
  .game-board {
    grid-template-columns: repeat(7, minmax(60px, 1fr));
    gap: 6px;
  }
  .card {
    width: 60px;
    height: 85px;
  }
}

@media (max-width: 900px) {
  .game-board {
    grid-template-columns: repeat(7, minmax(50px, 1fr));
    gap: 5px;
  }
  .card {
    width: 50px;
    height: 70px;
    font-size: 12px;
  }
  .tableau-pile {
    min-height: 150px;
  }
  .foundation, .stock, .waste {
    min-height: 80px;
  }
}

@media (max-width: 600px) {
  body {
    padding: 5px;
  }
  
  .header {
    flex-direction: column;
    gap: 15px;
    text-align: center;
  }
  
  .stats {
    gap: 10px;
    justify-content: center;
    flex-wrap: wrap;
  }
  
  .game-board {
    grid-template-columns: repeat(7, minmax(45px, 1fr));
    gap: 4px;
  }
  
  .card {
    width: 45px;
    height: 63px;
    font-size: 11px;
  }
  
  .tableau-pile {
    min-height: 120px;
  }
  
  .foundation, .stock, .waste {
    min-height: 70px;
  }
}

@media (max-width: 420px) {
  .game-board {
    grid-template-columns: repeat(7, minmax(40px, 1fr));
    gap: 3px;
  }
  
  .card {
    width: 40px;
    height: 56px;
    font-size: 10px;
  }
  
  .tableau-pile {
    min-height: 100px;
  }
  
  .foundation, .stock, .waste {
    min-height: 60px;
  }
}

/* Mensagem de vit√≥ria */
.win-message {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0,0,0,0.95);
  color: white;
  padding: 30px;
  border-radius: 20px;
  text-align: center;
  z-index: 2000;
  display: none;
  backdrop-filter: blur(15px);
  border: 2px solid #4ecdc4;
  box-shadow: 0 20px 50px rgba(0,0,0,0.8);
  max-width: 90vw;
}

.win-title {
  font-size: clamp(1.5rem, 5vw, 2.5rem);
  color: #4ecdc4;
  margin-bottom: 15px;
  text-shadow: 0 0 10px rgba(78, 205, 196, 0.5);
}

.win-message .stats {
  margin: 20px 0;
  justify-content: center;
}

/* Confete */
.celebration {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 1500;
}

.confetti {
  position: absolute;
  width: 10px;
  height: 10px;
  background: #4ecdc4;
  animation: confetti-fall 3s linear infinite;
}

@keyframes confetti-fall {
  0% {
    transform: translateY(-100vh) rotate(0deg);
    opacity: 1;
  }
  100% {
    transform: translateY(100vh) rotate(720deg);
    opacity: 0;
  }
}

/* Melhorias visuais */
.stock:empty::before {
  content: "üîÑ";
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 24px;
  color: rgba(255,255,255,0.5);
}

.foundation:empty::before {
  content: "A";
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 20px;
  color: rgba(255,255,255,0.3);
  font-weight: bold;
}
</style>
</head>
<body>

<div class="game-container">
  <div class="header">
    <h1>üÉè Paci√™ncia</h1>
    <div class="stats">
      <span>‚è±Ô∏è <span id="time">00:00</span></span>
      <span>üéØ <span id="moves">0</span></span>
      <span>‚≠ê <span id="score">0</span></span>
    </div>
    <button class="new-game-btn" onclick="game.newGame()">üîÑ Novo Jogo</button>
  </div>

  <div class="game-board">
    <div class="stock" id="stock"></div>
    <div class="waste" id="waste"></div>
    <div></div>
    <div class="foundation" id="foundation-0"></div>
    <div class="foundation" id="foundation-1"></div>
    <div class="foundation" id="foundation-2"></div>
    <div class="foundation" id="foundation-3"></div>
    <div class="tableau-pile" id="tableau-0"></div>
    <div class="tableau-pile" id="tableau-1"></div>
    <div class="tableau-pile" id="tableau-2"></div>
    <div class="tableau-pile" id="tableau-3"></div>
    <div class="tableau-pile" id="tableau-4"></div>
    <div class="tableau-pile" id="tableau-5"></div>
    <div class="tableau-pile" id="tableau-6"></div>
  </div>
</div>

<div class="win-message" id="winMessage">
  <div class="win-title">üéâ Parab√©ns!</div>
  <div style="font-size: 1.2rem; margin-bottom: 20px;">Voc√™ venceu o jogo!</div>
  <div class="stats">
    <span>‚è±Ô∏è <span id="finalTime"></span></span>
    <span>üéØ <span id="finalMoves"></span></span>
    <span>‚≠ê <span id="finalScore"></span></span>
  </div>
  <button class="new-game-btn" onclick="game.closeWinMessage()">üîÑ Jogar Novamente</button>
</div>

<div class="celebration" id="celebration"></div>

<script>
class Solitaire {
  constructor() {
    this.suits = ['‚ô†', '‚ô•', '‚ô£', '‚ô¶'];
    this.ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
    this.stock = [];
    this.waste = [];
    this.foundations = [[], [], [], []];
    this.tableau = [[], [], [], [], [], [], []];
    this.draggedCard = null;
    this.draggedFrom = null;
    this.draggedStack = [];
    this.offsetX = 0;
    this.offsetY = 0;
    this.lastX = null;
    this.lastY = null;
    this.moves = 0;
    this.score = 0;
    this.startTime = null;
    this.timer = null;
    this.isDragging = false;
    this.init();
  }

  init() {
    this.newGame();
  }

  newGame() {
    this.deck = [];
    for (let s of this.suits) {
      for (let r of this.ranks) {
        this.deck.push({
          suit: s,
          rank: r,
          color: (s === '‚ô•' || s === '‚ô¶') ? 'red' : 'black',
          faceUp: false,
          id: `${s}${r}${Math.random().toString(36).slice(2, 8)}`
        });
      }
    }

    // Embaralhar
    for (let i = this.deck.length - 1; i > 0; i--) {
      let j = Math.floor(Math.random() * (i + 1));
      [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
    }

    this.stock = [...this.deck];
    this.waste = [];
    this.foundations = [[], [], [], []];
    this.tableau = [[], [], [], [], [], [], []];
    this.moves = 0;
    this.score = 0;
    this.startTime = Date.now();
    
    if (this.timer) clearInterval(this.timer);
    this.timer = setInterval(() => this.updateTime(), 1000);

    // Distribuir cartas iniciais
    for (let i = 0; i < 7; i++) {
      for (let j = 0; j <= i; j++) {
        let card = this.stock.pop();
        card.faceUp = (j === i);
        this.tableau[i].push(card);
      }
    }

    this.render();
    this.bindEvents();
  }

  render() {
    this.renderStock();
    this.renderWaste();
    this.renderFoundations();
    this.renderTableau();
    document.getElementById('moves').innerText = this.moves;
    document.getElementById('score').innerText = this.score;
  }

  renderStock() {
    const stockEl = document.getElementById('stock');
    stockEl.innerHTML = '';
    
    if (this.stock.length > 0) {
      let cardEl = document.createElement('div');
      cardEl.className = 'card face-down';
      cardEl.innerHTML = 'üÇ†';
      stockEl.appendChild(cardEl);
    }
  }

  renderWaste() {
    const wasteEl = document.getElementById('waste');
    wasteEl.innerHTML = '';
    
    if (this.waste.length > 0) {
      const card = this.waste[this.waste.length - 1];
      const cardEl = this.createCardElement(card);
      cardEl.dataset.pile = 'waste';
      cardEl.dataset.index = this.waste.length - 1;
      wasteEl.appendChild(cardEl);
    }
  }

  renderFoundations() {
    for (let i = 0; i < 4; i++) {
      const el = document.getElementById(`foundation-${i}`);
      el.innerHTML = '';
      
      if (this.foundations[i].length > 0) {
        const top = this.foundations[i][this.foundations[i].length - 1];
        const cardEl = this.createCardElement(top);
        cardEl.dataset.pile = `foundation-${i}`;
        cardEl.dataset.index = this.foundations[i].length - 1;
        el.appendChild(cardEl);
      }
    }
  }

  renderTableau() {
    for (let i = 0; i < 7; i++) {
      const el = document.getElementById(`tableau-${i}`);
      el.innerHTML = '';
      
      this.tableau[i].forEach((card, index) => {
        const cardEl = this.createCardElement(card);
        cardEl.style.top = `${index * Math.min(25, Math.max(15, window.innerHeight / 30))}px`;
        cardEl.dataset.pile = `tableau-${i}`;
        cardEl.dataset.index = index;
        cardEl.style.zIndex = index + 1;
        el.appendChild(cardEl);
      });
    }
  }

  createCardElement(card) {
    const el = document.createElement('div');
    el.className = `card ${card.color} ${card.faceUp ? '' : 'face-down'}`;
    el.dataset.id = card.id;
    el.innerHTML = card.faceUp ? `${card.rank}<br>${card.suit}` : 'üÇ†';

    if (card.faceUp) {
      el.addEventListener('mousedown', (e) => this.startDrag(e, card));
      el.addEventListener('touchstart', (e) => this.startDrag(e, card), { passive: false });
    }

    return el;
  }

  startDrag(e, card) {
    if (!card.faceUp || this.isDragging) return;

    e.preventDefault();
    this.isDragging = true;

    const cardEl = e.target.closest('.card');
    const pileEl = cardEl.closest('.tableau-pile, .waste, .foundation');
    
    if (!pileEl) return;

    // N√£o permitir arrastar das foundations
    if (pileEl.classList.contains('foundation')) {
      this.isDragging = false;
      return;
    }

    this.draggedCard = card;
    this.draggedFrom = pileEl.id;

    // Determinar quais cartas arrastar (para tableau, pode ser uma sequ√™ncia)
    if (pileEl.classList.contains('tableau-pile')) {
      const colIndex = parseInt(this.draggedFrom.split('-')[1]);
      const cardIndex = parseInt(cardEl.dataset.index);
      
      // Verificar se a sequ√™ncia √© v√°lida para arrastar
      if (this.isValidSequence(this.tableau[colIndex], cardIndex)) {
        this.draggedStack = this.tableau[colIndex].slice(cardIndex);
      } else {
        this.isDragging = false;
        return;
      }
    } else {
      this.draggedStack = [card];
    }

    const rect = cardEl.getBoundingClientRect();
    const clientX = e.clientX !== undefined ? e.clientX : e.touches[0].clientX;
    const clientY = e.clientY !== undefined ? e.clientY : e.touches[0].clientY;
    
    this.offsetX = clientX - rect.left;
    this.offsetY = clientY - rect.top;
    this.lastX = clientX;
    this.lastY = clientY;

    // Eventos globais
    const mouseMoveHandler = (ev) => this.drag(ev);
    const mouseUpHandler = () => this.endDrag(mouseMoveHandler, mouseUpHandler);

    document.addEventListener('mousemove', mouseMoveHandler);
    document.addEventListener('mouseup', mouseUpHandler);
    document.addEventListener('touchmove', mouseMoveHandler, { passive: false });
    document.addEventListener('touchend', mouseUpHandler);
  }

  isValidSequence(column, startIndex) {
    for (let i = startIndex; i < column.length - 1; i++) {
      const current = column[i];
      const next = column[i + 1];
      
      const currentVal = this.ranks.indexOf(current.rank);
      const nextVal = this.ranks.indexOf(next.rank);
      
      if (current.color === next.color || currentVal !== nextVal + 1) {
        return false;
      }
    }
    return true;
  }

  drag(e) {
    if (!this.isDragging || !this.draggedCard) return;

    e.preventDefault();

    const clientX = e.clientX !== undefined ? e.clientX : e.touches[0].clientX;
    const clientY = e.clientY !== undefined ? e.clientY : e.touches[0].clientY;
    
    if (clientX == null || clientY == null) return;

    this.lastX = clientX;
    this.lastY = clientY;

    // Mover todas as cartas da pilha
    this.draggedStack.forEach((card, index) => {
      const el = document.querySelector(`[data-id='${card.id}']`);
      if (el) {
        el.classList.add('dragging');
        el.style.position = 'fixed';
        el.style.left = (clientX - this.offsetX) + 'px';
        el.style.top = (clientY - this.offsetY + index * 20) + 'px';
        el.style.zIndex = 2000 + index;
      }
    });

    // Highlight de zonas de drop
    this.updateDropZones(clientX, clientY);
  }

  updateDropZones(x, y) {
    // Remover highlights anteriores
    document.querySelectorAll('.drop-zone').forEach(el => {
      el.classList.remove('drop-zone');
    });

    // Adicionar highlight na zona atual
    const elementUnder = document.elementFromPoint(x, y);
    const dropZone = elementUnder?.closest('.tableau-pile, .foundation');
    
    if (dropZone && this.canDropAt(dropZone)) {
      dropZone.classList.add('drop-zone');
    }
  }

  canDropAt(dropZone) {
    if (dropZone.classList.contains('tableau-pile')) {
      const colIndex = parseInt(dropZone.id.split('-')[1]);
      return this.canMoveToTableau(this.draggedStack[0], colIndex);
    } else if (dropZone.classList.contains('foundation')) {
      const foundIndex = parseInt(dropZone.id.split('-')[1]);
      return this.draggedStack.length === 1 && this.canMoveToFoundation(this.draggedStack[0], foundIndex);
    }
    return false;
  }

  endDrag(mouseMoveHandler, mouseUpHandler) {
    document.removeEventListener('mousemove', mouseMoveHandler);
    document.removeEventListener('mouseup', mouseUpHandler);
    document.removeEventListener('touchmove', mouseMoveHandler);
    document.removeEventListener('touchend', mouseUpHandler);

    if (!this.isDragging || !this.draggedCard) {
      this.isDragging = false;
      return;
    }

    // Remover highlights
    document.querySelectorAll('.drop-zone').forEach(el => {
      el.classList.remove('drop-zone');
    });

    let moved = false;
    const x = this.lastX || window.innerWidth / 2;
    const y = this.lastY || window.innerHeight / 2;

    // Tentar drop em tableau
    document.querySelectorAll('.tableau-pile').forEach((pile, i) => {
      const rect = pile.getBoundingClientRect();
      if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
        if (this.canMoveToTableau(this.draggedStack[0], i)) {
          this.moveToTableau(i);
          moved = true;
        }
      }
    });

    // Tentar drop em foundations (apenas carta √∫nica)
    if (!moved && this.draggedStack.length === 1) {
      document.querySelectorAll('.foundation').forEach((foundation, i) => {
        const rect = foundation.getBoundingClientRect();
        if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
          if (this.canMoveToFoundation(this.draggedStack[0], i)) {
            this.moveToFoundation(i);
            moved = true;
          }
        }
      });
    }

    // Reset visual das cartas
    this.draggedStack.forEach(card => {
      const el = document.querySelector(`[data-id='${card.id}']`);
      if (el) {
        el.classList.remove('dragging');
        el.style.position = 'absolute';
        el.style.left = '';
        el.style.top = '';
        el.style.zIndex = '';
      }
    });

    // Cleanup
    this.draggedCard = null;
    this.draggedFrom = null;
    this.draggedStack = [];
    this.isDragging = false;

    if (moved) {
      this.moves++;
      this.score += 5;
    }

    this.render();
    this.checkWin();
  }

  canMoveToTableau(card, colIndex) {
    const dest = this.tableau[colIndex];
    if (dest.length === 0) return card.rank === 'K';
    
    const top = dest[dest.length - 1];
    const cardVal = this.ranks.indexOf(card.rank);
    const topVal = this.ranks.indexOf(top.rank);
    
    return card.color !== top.color && cardVal === topVal - 1;
  }

  moveToTableau(colIndex) {
    // Remover da origem
    if (this.draggedFrom === 'waste') {
      this.waste.pop();
    } else if (this.draggedFrom.startsWith('tableau-')) {
      const fromCol = parseInt(this.draggedFrom.split('-')[1]);
      const removeCount = this.draggedStack.length;
      this.tableau[fromCol].splice(-removeCount);
      
      // Virar carta se necess√°rio
      if (this.tableau[fromCol].length > 0) {
        const lastCard = this.tableau[fromCol][this.tableau[fromCol].length - 1];
        if (!lastCard.faceUp) {
          lastCard.faceUp = true;
          this.score += 5;
        }
      }
    }

    // Adicionar ao destino
    this.tableau[colIndex] = this.tableau[colIndex].concat(this.draggedStack);
  }

  canMoveToFoundation(card, foundIndex) {
    const pile = this.foundations[foundIndex];
    if (pile.length === 0) return card.rank === 'A';
    
    const top = pile[pile.length - 1];
    const cardVal = this.ranks.indexOf(card.rank);
    const topVal = this.ranks.indexOf(top.rank);
    
    return card.suit === top.suit && cardVal === topVal + 1;
  }

  moveToFoundation(foundIndex) {
    const card = this.draggedStack[0];
    
    // Remover da origem
    if (this.draggedFrom === 'waste') {
      this.waste.pop();
    } else if (this.draggedFrom.startsWith('tableau-')) {
      const fromCol = parseInt(this.draggedFrom.split('-')[1]);
      this.tableau[fromCol].pop();
      
      // Virar carta se necess√°rio
      if (this.tableau[fromCol].length > 0) {
        const lastCard = this.tableau[fromCol][this.tableau[fromCol].length - 1];
        if (!lastCard.faceUp) {
          lastCard.faceUp = true;
          this.score += 5;
        }
      }
    }
    this.tableau[colIndex] = this.tableau[colIndex].concat(this.draggedStack);
  }
  canMoveToFoundation(card,foundIndex) {
    const pile = this.foundations[foundIndex];
    if (pile.length === 0) return card.rank === 'A';

    const top = pile[pile.length - 1];
    const cardVal = this.ranks.indexOf(card.rank);
    const topVal = this.ranks.indexOf(top.rank);

  return card.suit === top.suit && cardVal === topVal + 1;
  }
  moveToFoundation(foundIndex) {
    const card = this.draggedStack[0];
    
    
    
